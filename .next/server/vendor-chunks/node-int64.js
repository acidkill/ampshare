/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-int64";
exports.ids = ["vendor-chunks/node-int64"];
exports.modules = {

/***/ "(action-browser)/./node_modules/node-int64/Int64.js":
/*!******************************************!*\
  !*** ./node_modules/node-int64/Int64.js ***!
  \******************************************/
/***/ ((module) => {

eval("//     Int64.js\n//\n//     Copyright (c) 2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n/**\n * Support for handling 64-bit int numbers in Javascript (node.js)\n *\n * JS Numbers are IEEE-754 binary double-precision floats, which limits the\n * range of values that can be represented with integer precision to:\n *\n * 2^^53 <= N <= 2^53\n *\n * Int64 objects wrap a node Buffer that holds the 8-bytes of int64 data.  These\n * objects operate directly on the buffer which means that if they are created\n * using an existing buffer then setting the value will modify the Buffer, and\n * vice-versa.\n *\n * Internal Representation\n *\n * The internal buffer format is Big Endian.  I.e. the most-significant byte is\n * at buffer[0], the least-significant at buffer[7].  For the purposes of\n * converting to/from JS native numbers, the value is assumed to be a signed\n * integer stored in 2's complement form.\n *\n * For details about IEEE-754 see:\n * http://en.wikipedia.org/wiki/Double_precision_floating-point_format\n */\n\n// Useful masks and values for bit twiddling\nvar MASK31 =  0x7fffffff, VAL31 = 0x80000000;\nvar MASK32 =  0xffffffff, VAL32 = 0x100000000;\n\n// Map for converting hex octets to strings\nvar _HEX = [];\nfor (var i = 0; i < 256; i++) {\n  _HEX[i] = (i > 0xF ? '' : '0') + i.toString(16);\n}\n\n//\n// Int64\n//\n\n/**\n * Constructor accepts any of the following argument types:\n *\n * new Int64(buffer[, offset=0]) - Existing Buffer with byte offset\n * new Int64(Uint8Array[, offset=0]) - Existing Uint8Array with a byte offset\n * new Int64(string)             - Hex string (throws if n is outside int64 range)\n * new Int64(number)             - Number (throws if n is outside int64 range)\n * new Int64(hi, lo)             - Raw bits as two 32-bit values\n */\nvar Int64 = module.exports = function(a1, a2) {\n  if (a1 instanceof Buffer) {\n    this.buffer = a1;\n    this.offset = a2 || 0;\n  } else if (Object.prototype.toString.call(a1) == '[object Uint8Array]') {\n    // Under Browserify, Buffers can extend Uint8Arrays rather than an\n    // instance of Buffer. We could assume the passed in Uint8Array is actually\n    // a buffer but that won't handle the case where a raw Uint8Array is passed\n    // in. We construct a new Buffer just in case.\n    this.buffer = new Buffer(a1);\n    this.offset = a2 || 0;\n  } else {\n    this.buffer = this.buffer || new Buffer(8);\n    this.offset = 0;\n    this.setValue.apply(this, arguments);\n  }\n};\n\n\n// Max integer value that JS can accurately represent\nInt64.MAX_INT = Math.pow(2, 53);\n\n// Min integer value that JS can accurately represent\nInt64.MIN_INT = -Math.pow(2, 53);\n\nInt64.prototype = {\n\n  constructor: Int64,\n\n  /**\n   * Do in-place 2's compliment.  See\n   * http://en.wikipedia.org/wiki/Two's_complement\n   */\n  _2scomp: function() {\n    var b = this.buffer, o = this.offset, carry = 1;\n    for (var i = o + 7; i >= o; i--) {\n      var v = (b[i] ^ 0xff) + carry;\n      b[i] = v & 0xff;\n      carry = v >> 8;\n    }\n  },\n\n  /**\n   * Set the value. Takes any of the following arguments:\n   *\n   * setValue(string) - A hexidecimal string\n   * setValue(number) - Number (throws if n is outside int64 range)\n   * setValue(hi, lo) - Raw bits as two 32-bit values\n   */\n  setValue: function(hi, lo) {\n    var negate = false;\n    if (arguments.length == 1) {\n      if (typeof(hi) == 'number') {\n        // Simplify bitfield retrieval by using abs() value.  We restore sign\n        // later\n        negate = hi < 0;\n        hi = Math.abs(hi);\n        lo = hi % VAL32;\n        hi = hi / VAL32;\n        if (hi > VAL32) throw new RangeError(hi  + ' is outside Int64 range');\n        hi = hi | 0;\n      } else if (typeof(hi) == 'string') {\n        hi = (hi + '').replace(/^0x/, '');\n        lo = hi.substr(-8);\n        hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : '';\n        hi = parseInt(hi, 16);\n        lo = parseInt(lo, 16);\n      } else {\n        throw new Error(hi + ' must be a Number or String');\n      }\n    }\n\n    // Technically we should throw if hi or lo is outside int32 range here, but\n    // it's not worth the effort. Anything past the 32'nd bit is ignored.\n\n    // Copy bytes to buffer\n    var b = this.buffer, o = this.offset;\n    for (var i = 7; i >= 0; i--) {\n      b[o+i] = lo & 0xff;\n      lo = i == 4 ? hi : lo >>> 8;\n    }\n\n    // Restore sign of passed argument\n    if (negate) this._2scomp();\n  },\n\n  /**\n   * Convert to a native JS number.\n   *\n   * WARNING: Do not expect this value to be accurate to integer precision for\n   * large (positive or negative) numbers!\n   *\n   * @param allowImprecise If true, no check is performed to verify the\n   * returned value is accurate to integer precision.  If false, imprecise\n   * numbers (very large positive or negative numbers) will be forced to +/-\n   * Infinity.\n   */\n  toNumber: function(allowImprecise) {\n    var b = this.buffer, o = this.offset;\n\n    // Running sum of octets, doing a 2's complement\n    var negate = b[o] & 0x80, x = 0, carry = 1;\n    for (var i = 7, m = 1; i >= 0; i--, m *= 256) {\n      var v = b[o+i];\n\n      // 2's complement for negative numbers\n      if (negate) {\n        v = (v ^ 0xff) + carry;\n        carry = v >> 8;\n        v = v & 0xff;\n      }\n\n      x += v * m;\n    }\n\n    // Return Infinity if we've lost integer precision\n    if (!allowImprecise && x >= Int64.MAX_INT) {\n      return negate ? -Infinity : Infinity;\n    }\n\n    return negate ? -x : x;\n  },\n\n  /**\n   * Convert to a JS Number. Returns +/-Infinity for values that can't be\n   * represented to integer precision.\n   */\n  valueOf: function() {\n    return this.toNumber(false);\n  },\n\n  /**\n   * Return string value\n   *\n   * @param radix Just like Number#toString()'s radix\n   */\n  toString: function(radix) {\n    return this.valueOf().toString(radix || 10);\n  },\n\n  /**\n   * Return a string showing the buffer octets, with MSB on the left.\n   *\n   * @param sep separator string. default is '' (empty string)\n   */\n  toOctetString: function(sep) {\n    var out = new Array(8);\n    var b = this.buffer, o = this.offset;\n    for (var i = 0; i < 8; i++) {\n      out[i] = _HEX[b[o+i]];\n    }\n    return out.join(sep || '');\n  },\n\n  /**\n   * Returns the int64's 8 bytes in a buffer.\n   *\n   * @param {bool} [rawBuffer=false]  If no offset and this is true, return the internal buffer.  Should only be used if\n   *                                  you're discarding the Int64 afterwards, as it breaks encapsulation.\n   */\n  toBuffer: function(rawBuffer) {\n    if (rawBuffer && this.offset === 0) return this.buffer;\n\n    var out = new Buffer(8);\n    this.buffer.copy(out, 0, this.offset, this.offset + 8);\n    return out;\n  },\n\n  /**\n   * Copy 8 bytes of int64 into target buffer at target offset.\n   *\n   * @param {Buffer} targetBuffer       Buffer to copy into.\n   * @param {number} [targetOffset=0]   Offset into target buffer.\n   */\n  copy: function(targetBuffer, targetOffset) {\n    this.buffer.copy(targetBuffer, targetOffset || 0, this.offset, this.offset + 8);\n  },\n\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other in sort order.\n   *\n   * @param {Int64} other  Other Int64 to compare.\n   */\n  compare: function(other) {\n\n    // If sign bits differ ...\n    if ((this.buffer[this.offset] & 0x80) != (other.buffer[other.offset] & 0x80)) {\n      return other.buffer[other.offset] - this.buffer[this.offset];\n    }\n\n    // otherwise, compare bytes lexicographically\n    for (var i = 0; i < 8; i++) {\n      if (this.buffer[this.offset+i] !== other.buffer[other.offset+i]) {\n        return this.buffer[this.offset+i] - other.buffer[other.offset+i];\n      }\n    }\n    return 0;\n  },\n\n  /**\n   * Returns a boolean indicating if this integer is equal to other.\n   *\n   * @param {Int64} other  Other Int64 to compare.\n   */\n  equals: function(other) {\n    return this.compare(other) === 0;\n  },\n\n  /**\n   * Pretty output in console.log\n   */\n  inspect: function() {\n    return '[Int64 value:' + this + ' octets:' + this.toOctetString(' ') + ']';\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWludDY0L0ludDY0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L25vZGVfbW9kdWxlcy9ub2RlLWludDY0L0ludDY0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vICAgICBJbnQ2NC5qc1xuLy9cbi8vICAgICBDb3B5cmlnaHQgKGMpIDIwMTIgUm9iZXJ0IEtpZWZmZXJcbi8vICAgICBNSVQgTGljZW5zZSAtIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblxuLyoqXG4gKiBTdXBwb3J0IGZvciBoYW5kbGluZyA2NC1iaXQgaW50IG51bWJlcnMgaW4gSmF2YXNjcmlwdCAobm9kZS5qcylcbiAqXG4gKiBKUyBOdW1iZXJzIGFyZSBJRUVFLTc1NCBiaW5hcnkgZG91YmxlLXByZWNpc2lvbiBmbG9hdHMsIHdoaWNoIGxpbWl0cyB0aGVcbiAqIHJhbmdlIG9mIHZhbHVlcyB0aGF0IGNhbiBiZSByZXByZXNlbnRlZCB3aXRoIGludGVnZXIgcHJlY2lzaW9uIHRvOlxuICpcbiAqIDJeXjUzIDw9IE4gPD0gMl41M1xuICpcbiAqIEludDY0IG9iamVjdHMgd3JhcCBhIG5vZGUgQnVmZmVyIHRoYXQgaG9sZHMgdGhlIDgtYnl0ZXMgb2YgaW50NjQgZGF0YS4gIFRoZXNlXG4gKiBvYmplY3RzIG9wZXJhdGUgZGlyZWN0bHkgb24gdGhlIGJ1ZmZlciB3aGljaCBtZWFucyB0aGF0IGlmIHRoZXkgYXJlIGNyZWF0ZWRcbiAqIHVzaW5nIGFuIGV4aXN0aW5nIGJ1ZmZlciB0aGVuIHNldHRpbmcgdGhlIHZhbHVlIHdpbGwgbW9kaWZ5IHRoZSBCdWZmZXIsIGFuZFxuICogdmljZS12ZXJzYS5cbiAqXG4gKiBJbnRlcm5hbCBSZXByZXNlbnRhdGlvblxuICpcbiAqIFRoZSBpbnRlcm5hbCBidWZmZXIgZm9ybWF0IGlzIEJpZyBFbmRpYW4uICBJLmUuIHRoZSBtb3N0LXNpZ25pZmljYW50IGJ5dGUgaXNcbiAqIGF0IGJ1ZmZlclswXSwgdGhlIGxlYXN0LXNpZ25pZmljYW50IGF0IGJ1ZmZlcls3XS4gIEZvciB0aGUgcHVycG9zZXMgb2ZcbiAqIGNvbnZlcnRpbmcgdG8vZnJvbSBKUyBuYXRpdmUgbnVtYmVycywgdGhlIHZhbHVlIGlzIGFzc3VtZWQgdG8gYmUgYSBzaWduZWRcbiAqIGludGVnZXIgc3RvcmVkIGluIDIncyBjb21wbGVtZW50IGZvcm0uXG4gKlxuICogRm9yIGRldGFpbHMgYWJvdXQgSUVFRS03NTQgc2VlOlxuICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VibGVfcHJlY2lzaW9uX2Zsb2F0aW5nLXBvaW50X2Zvcm1hdFxuICovXG5cbi8vIFVzZWZ1bCBtYXNrcyBhbmQgdmFsdWVzIGZvciBiaXQgdHdpZGRsaW5nXG52YXIgTUFTSzMxID0gIDB4N2ZmZmZmZmYsIFZBTDMxID0gMHg4MDAwMDAwMDtcbnZhciBNQVNLMzIgPSAgMHhmZmZmZmZmZiwgVkFMMzIgPSAweDEwMDAwMDAwMDtcblxuLy8gTWFwIGZvciBjb252ZXJ0aW5nIGhleCBvY3RldHMgdG8gc3RyaW5nc1xudmFyIF9IRVggPSBbXTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgX0hFWFtpXSA9IChpID4gMHhGID8gJycgOiAnMCcpICsgaS50b1N0cmluZygxNik7XG59XG5cbi8vXG4vLyBJbnQ2NFxuLy9cblxuLyoqXG4gKiBDb25zdHJ1Y3RvciBhY2NlcHRzIGFueSBvZiB0aGUgZm9sbG93aW5nIGFyZ3VtZW50IHR5cGVzOlxuICpcbiAqIG5ldyBJbnQ2NChidWZmZXJbLCBvZmZzZXQ9MF0pIC0gRXhpc3RpbmcgQnVmZmVyIHdpdGggYnl0ZSBvZmZzZXRcbiAqIG5ldyBJbnQ2NChVaW50OEFycmF5Wywgb2Zmc2V0PTBdKSAtIEV4aXN0aW5nIFVpbnQ4QXJyYXkgd2l0aCBhIGJ5dGUgb2Zmc2V0XG4gKiBuZXcgSW50NjQoc3RyaW5nKSAgICAgICAgICAgICAtIEhleCBzdHJpbmcgKHRocm93cyBpZiBuIGlzIG91dHNpZGUgaW50NjQgcmFuZ2UpXG4gKiBuZXcgSW50NjQobnVtYmVyKSAgICAgICAgICAgICAtIE51bWJlciAodGhyb3dzIGlmIG4gaXMgb3V0c2lkZSBpbnQ2NCByYW5nZSlcbiAqIG5ldyBJbnQ2NChoaSwgbG8pICAgICAgICAgICAgIC0gUmF3IGJpdHMgYXMgdHdvIDMyLWJpdCB2YWx1ZXNcbiAqL1xudmFyIEludDY0ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhMSwgYTIpIHtcbiAgaWYgKGExIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgdGhpcy5idWZmZXIgPSBhMTtcbiAgICB0aGlzLm9mZnNldCA9IGEyIHx8IDA7XG4gIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGExKSA9PSAnW29iamVjdCBVaW50OEFycmF5XScpIHtcbiAgICAvLyBVbmRlciBCcm93c2VyaWZ5LCBCdWZmZXJzIGNhbiBleHRlbmQgVWludDhBcnJheXMgcmF0aGVyIHRoYW4gYW5cbiAgICAvLyBpbnN0YW5jZSBvZiBCdWZmZXIuIFdlIGNvdWxkIGFzc3VtZSB0aGUgcGFzc2VkIGluIFVpbnQ4QXJyYXkgaXMgYWN0dWFsbHlcbiAgICAvLyBhIGJ1ZmZlciBidXQgdGhhdCB3b24ndCBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYSByYXcgVWludDhBcnJheSBpcyBwYXNzZWRcbiAgICAvLyBpbi4gV2UgY29uc3RydWN0IGEgbmV3IEJ1ZmZlciBqdXN0IGluIGNhc2UuXG4gICAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyKGExKTtcbiAgICB0aGlzLm9mZnNldCA9IGEyIHx8IDA7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlciB8fCBuZXcgQnVmZmVyKDgpO1xuICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICB0aGlzLnNldFZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbn07XG5cblxuLy8gTWF4IGludGVnZXIgdmFsdWUgdGhhdCBKUyBjYW4gYWNjdXJhdGVseSByZXByZXNlbnRcbkludDY0Lk1BWF9JTlQgPSBNYXRoLnBvdygyLCA1Myk7XG5cbi8vIE1pbiBpbnRlZ2VyIHZhbHVlIHRoYXQgSlMgY2FuIGFjY3VyYXRlbHkgcmVwcmVzZW50XG5JbnQ2NC5NSU5fSU5UID0gLU1hdGgucG93KDIsIDUzKTtcblxuSW50NjQucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBJbnQ2NCxcblxuICAvKipcbiAgICogRG8gaW4tcGxhY2UgMidzIGNvbXBsaW1lbnQuICBTZWVcbiAgICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ud28nc19jb21wbGVtZW50XG4gICAqL1xuICBfMnNjb21wOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYiA9IHRoaXMuYnVmZmVyLCBvID0gdGhpcy5vZmZzZXQsIGNhcnJ5ID0gMTtcbiAgICBmb3IgKHZhciBpID0gbyArIDc7IGkgPj0gbzsgaS0tKSB7XG4gICAgICB2YXIgdiA9IChiW2ldIF4gMHhmZikgKyBjYXJyeTtcbiAgICAgIGJbaV0gPSB2ICYgMHhmZjtcbiAgICAgIGNhcnJ5ID0gdiA+PiA4O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0IHRoZSB2YWx1ZS4gVGFrZXMgYW55IG9mIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzOlxuICAgKlxuICAgKiBzZXRWYWx1ZShzdHJpbmcpIC0gQSBoZXhpZGVjaW1hbCBzdHJpbmdcbiAgICogc2V0VmFsdWUobnVtYmVyKSAtIE51bWJlciAodGhyb3dzIGlmIG4gaXMgb3V0c2lkZSBpbnQ2NCByYW5nZSlcbiAgICogc2V0VmFsdWUoaGksIGxvKSAtIFJhdyBiaXRzIGFzIHR3byAzMi1iaXQgdmFsdWVzXG4gICAqL1xuICBzZXRWYWx1ZTogZnVuY3Rpb24oaGksIGxvKSB7XG4gICAgdmFyIG5lZ2F0ZSA9IGZhbHNlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgIGlmICh0eXBlb2YoaGkpID09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIFNpbXBsaWZ5IGJpdGZpZWxkIHJldHJpZXZhbCBieSB1c2luZyBhYnMoKSB2YWx1ZS4gIFdlIHJlc3RvcmUgc2lnblxuICAgICAgICAvLyBsYXRlclxuICAgICAgICBuZWdhdGUgPSBoaSA8IDA7XG4gICAgICAgIGhpID0gTWF0aC5hYnMoaGkpO1xuICAgICAgICBsbyA9IGhpICUgVkFMMzI7XG4gICAgICAgIGhpID0gaGkgLyBWQUwzMjtcbiAgICAgICAgaWYgKGhpID4gVkFMMzIpIHRocm93IG5ldyBSYW5nZUVycm9yKGhpICArICcgaXMgb3V0c2lkZSBJbnQ2NCByYW5nZScpO1xuICAgICAgICBoaSA9IGhpIHwgMDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGhpKSA9PSAnc3RyaW5nJykge1xuICAgICAgICBoaSA9IChoaSArICcnKS5yZXBsYWNlKC9eMHgvLCAnJyk7XG4gICAgICAgIGxvID0gaGkuc3Vic3RyKC04KTtcbiAgICAgICAgaGkgPSBoaS5sZW5ndGggPiA4ID8gaGkuc3Vic3RyKDAsIGhpLmxlbmd0aCAtIDgpIDogJyc7XG4gICAgICAgIGhpID0gcGFyc2VJbnQoaGksIDE2KTtcbiAgICAgICAgbG8gPSBwYXJzZUludChsbywgMTYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGhpICsgJyBtdXN0IGJlIGEgTnVtYmVyIG9yIFN0cmluZycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRlY2huaWNhbGx5IHdlIHNob3VsZCB0aHJvdyBpZiBoaSBvciBsbyBpcyBvdXRzaWRlIGludDMyIHJhbmdlIGhlcmUsIGJ1dFxuICAgIC8vIGl0J3Mgbm90IHdvcnRoIHRoZSBlZmZvcnQuIEFueXRoaW5nIHBhc3QgdGhlIDMyJ25kIGJpdCBpcyBpZ25vcmVkLlxuXG4gICAgLy8gQ29weSBieXRlcyB0byBidWZmZXJcbiAgICB2YXIgYiA9IHRoaXMuYnVmZmVyLCBvID0gdGhpcy5vZmZzZXQ7XG4gICAgZm9yICh2YXIgaSA9IDc7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBiW28raV0gPSBsbyAmIDB4ZmY7XG4gICAgICBsbyA9IGkgPT0gNCA/IGhpIDogbG8gPj4+IDg7XG4gICAgfVxuXG4gICAgLy8gUmVzdG9yZSBzaWduIG9mIHBhc3NlZCBhcmd1bWVudFxuICAgIGlmIChuZWdhdGUpIHRoaXMuXzJzY29tcCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRvIGEgbmF0aXZlIEpTIG51bWJlci5cbiAgICpcbiAgICogV0FSTklORzogRG8gbm90IGV4cGVjdCB0aGlzIHZhbHVlIHRvIGJlIGFjY3VyYXRlIHRvIGludGVnZXIgcHJlY2lzaW9uIGZvclxuICAgKiBsYXJnZSAocG9zaXRpdmUgb3IgbmVnYXRpdmUpIG51bWJlcnMhXG4gICAqXG4gICAqIEBwYXJhbSBhbGxvd0ltcHJlY2lzZSBJZiB0cnVlLCBubyBjaGVjayBpcyBwZXJmb3JtZWQgdG8gdmVyaWZ5IHRoZVxuICAgKiByZXR1cm5lZCB2YWx1ZSBpcyBhY2N1cmF0ZSB0byBpbnRlZ2VyIHByZWNpc2lvbi4gIElmIGZhbHNlLCBpbXByZWNpc2VcbiAgICogbnVtYmVycyAodmVyeSBsYXJnZSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXJzKSB3aWxsIGJlIGZvcmNlZCB0byArLy1cbiAgICogSW5maW5pdHkuXG4gICAqL1xuICB0b051bWJlcjogZnVuY3Rpb24oYWxsb3dJbXByZWNpc2UpIHtcbiAgICB2YXIgYiA9IHRoaXMuYnVmZmVyLCBvID0gdGhpcy5vZmZzZXQ7XG5cbiAgICAvLyBSdW5uaW5nIHN1bSBvZiBvY3RldHMsIGRvaW5nIGEgMidzIGNvbXBsZW1lbnRcbiAgICB2YXIgbmVnYXRlID0gYltvXSAmIDB4ODAsIHggPSAwLCBjYXJyeSA9IDE7XG4gICAgZm9yICh2YXIgaSA9IDcsIG0gPSAxOyBpID49IDA7IGktLSwgbSAqPSAyNTYpIHtcbiAgICAgIHZhciB2ID0gYltvK2ldO1xuXG4gICAgICAvLyAyJ3MgY29tcGxlbWVudCBmb3IgbmVnYXRpdmUgbnVtYmVyc1xuICAgICAgaWYgKG5lZ2F0ZSkge1xuICAgICAgICB2ID0gKHYgXiAweGZmKSArIGNhcnJ5O1xuICAgICAgICBjYXJyeSA9IHYgPj4gODtcbiAgICAgICAgdiA9IHYgJiAweGZmO1xuICAgICAgfVxuXG4gICAgICB4ICs9IHYgKiBtO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBJbmZpbml0eSBpZiB3ZSd2ZSBsb3N0IGludGVnZXIgcHJlY2lzaW9uXG4gICAgaWYgKCFhbGxvd0ltcHJlY2lzZSAmJiB4ID49IEludDY0Lk1BWF9JTlQpIHtcbiAgICAgIHJldHVybiBuZWdhdGUgPyAtSW5maW5pdHkgOiBJbmZpbml0eTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmVnYXRlID8gLXggOiB4O1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRvIGEgSlMgTnVtYmVyLiBSZXR1cm5zICsvLUluZmluaXR5IGZvciB2YWx1ZXMgdGhhdCBjYW4ndCBiZVxuICAgKiByZXByZXNlbnRlZCB0byBpbnRlZ2VyIHByZWNpc2lvbi5cbiAgICovXG4gIHZhbHVlT2Y6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRvTnVtYmVyKGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIHN0cmluZyB2YWx1ZVxuICAgKlxuICAgKiBAcGFyYW0gcmFkaXggSnVzdCBsaWtlIE51bWJlciN0b1N0cmluZygpJ3MgcmFkaXhcbiAgICovXG4gIHRvU3RyaW5nOiBmdW5jdGlvbihyYWRpeCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKS50b1N0cmluZyhyYWRpeCB8fCAxMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHN0cmluZyBzaG93aW5nIHRoZSBidWZmZXIgb2N0ZXRzLCB3aXRoIE1TQiBvbiB0aGUgbGVmdC5cbiAgICpcbiAgICogQHBhcmFtIHNlcCBzZXBhcmF0b3Igc3RyaW5nLiBkZWZhdWx0IGlzICcnIChlbXB0eSBzdHJpbmcpXG4gICAqL1xuICB0b09jdGV0U3RyaW5nOiBmdW5jdGlvbihzZXApIHtcbiAgICB2YXIgb3V0ID0gbmV3IEFycmF5KDgpO1xuICAgIHZhciBiID0gdGhpcy5idWZmZXIsIG8gPSB0aGlzLm9mZnNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgb3V0W2ldID0gX0hFWFtiW28raV1dO1xuICAgIH1cbiAgICByZXR1cm4gb3V0LmpvaW4oc2VwIHx8ICcnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW50NjQncyA4IGJ5dGVzIGluIGEgYnVmZmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2x9IFtyYXdCdWZmZXI9ZmFsc2VdICBJZiBubyBvZmZzZXQgYW5kIHRoaXMgaXMgdHJ1ZSwgcmV0dXJuIHRoZSBpbnRlcm5hbCBidWZmZXIuICBTaG91bGQgb25seSBiZSB1c2VkIGlmXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlvdSdyZSBkaXNjYXJkaW5nIHRoZSBJbnQ2NCBhZnRlcndhcmRzLCBhcyBpdCBicmVha3MgZW5jYXBzdWxhdGlvbi5cbiAgICovXG4gIHRvQnVmZmVyOiBmdW5jdGlvbihyYXdCdWZmZXIpIHtcbiAgICBpZiAocmF3QnVmZmVyICYmIHRoaXMub2Zmc2V0ID09PSAwKSByZXR1cm4gdGhpcy5idWZmZXI7XG5cbiAgICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcig4KTtcbiAgICB0aGlzLmJ1ZmZlci5jb3B5KG91dCwgMCwgdGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICsgOCk7XG4gICAgcmV0dXJuIG91dDtcbiAgfSxcblxuICAvKipcbiAgICogQ29weSA4IGJ5dGVzIG9mIGludDY0IGludG8gdGFyZ2V0IGJ1ZmZlciBhdCB0YXJnZXQgb2Zmc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gdGFyZ2V0QnVmZmVyICAgICAgIEJ1ZmZlciB0byBjb3B5IGludG8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGFyZ2V0T2Zmc2V0PTBdICAgT2Zmc2V0IGludG8gdGFyZ2V0IGJ1ZmZlci5cbiAgICovXG4gIGNvcHk6IGZ1bmN0aW9uKHRhcmdldEJ1ZmZlciwgdGFyZ2V0T2Zmc2V0KSB7XG4gICAgdGhpcy5idWZmZXIuY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldE9mZnNldCB8fCAwLCB0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyA4KTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIG51bWJlciBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBjb21lcyBiZWZvcmUgb3IgYWZ0ZXIgb3IgaXMgdGhlXG4gICAqIHNhbWUgYXMgdGhlIG90aGVyIGluIHNvcnQgb3JkZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7SW50NjR9IG90aGVyICBPdGhlciBJbnQ2NCB0byBjb21wYXJlLlxuICAgKi9cbiAgY29tcGFyZTogZnVuY3Rpb24ob3RoZXIpIHtcblxuICAgIC8vIElmIHNpZ24gYml0cyBkaWZmZXIgLi4uXG4gICAgaWYgKCh0aGlzLmJ1ZmZlclt0aGlzLm9mZnNldF0gJiAweDgwKSAhPSAob3RoZXIuYnVmZmVyW290aGVyLm9mZnNldF0gJiAweDgwKSkge1xuICAgICAgcmV0dXJuIG90aGVyLmJ1ZmZlcltvdGhlci5vZmZzZXRdIC0gdGhpcy5idWZmZXJbdGhpcy5vZmZzZXRdO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSwgY29tcGFyZSBieXRlcyBsZXhpY29ncmFwaGljYWxseVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5idWZmZXJbdGhpcy5vZmZzZXQraV0gIT09IG90aGVyLmJ1ZmZlcltvdGhlci5vZmZzZXQraV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMub2Zmc2V0K2ldIC0gb3RoZXIuYnVmZmVyW290aGVyLm9mZnNldCtpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhpcyBpbnRlZ2VyIGlzIGVxdWFsIHRvIG90aGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0ludDY0fSBvdGhlciAgT3RoZXIgSW50NjQgdG8gY29tcGFyZS5cbiAgICovXG4gIGVxdWFsczogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlKG90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcbiAgICogUHJldHR5IG91dHB1dCBpbiBjb25zb2xlLmxvZ1xuICAgKi9cbiAgaW5zcGVjdDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICdbSW50NjQgdmFsdWU6JyArIHRoaXMgKyAnIG9jdGV0czonICsgdGhpcy50b09jdGV0U3RyaW5nKCcgJykgKyAnXSc7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-int64/Int64.js\n");

/***/ })

};
;